<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BASS SURVIVOR</title>
  <meta name="description" content="play bass to defend your castle">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Syne+Mono&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0f;
      color: #fff;
      font-family: 'Syne Mono', monospace;
      overflow: hidden;
      height: 100vh;
      cursor: crosshair;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
    }
    
    #game-container {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, #142238, #0a1628);
    }
    
    #game-container::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px);
      pointer-events: none;
      z-index: 100;
    }
    
    #vignette {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.5) 100%);
      pointer-events: none;
      z-index: 99;
    }
    
    canvas { display: block; }
    
    .ui-text {
      position: fixed;
      font-family: 'Syne Mono', monospace;
      z-index: 200;
    }
    
    #score-display {
      top: 30px; left: 30px;
      font-size: 28px;
      color: #ffcc00;
      text-shadow: 0 0 15px #ffcc00, 0 0 30px #ff8800, 2px 2px 0 #000;
    }
    
    #wave-display {
      top: 30px; left: 50%;
      transform: translateX(-50%);
      font-size: 42px;
      color: #fff;
      text-shadow: 0 0 20px #fff, 0 0 40px #00ffcc, 2px 2px 0 #000;
    }
    
    #combo-display {
      top: 65px; left: 30px;
      font-size: 28px;
      color: #ff00ff;
      text-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff, 2px 2px 0 #000;
      opacity: 0;
      transition: opacity 0.1s;
    }
    
    #combo-display.active { opacity: 1; }
    
    #wrong-note {
      top: 105px; left: 30px;
      font-size: 28px;
      color: #f00;
      text-shadow: 0 0 20px #f00, 0 0 40px #f00, 2px 2px 0 #000;
      opacity: 0;
      transition: opacity 0.1s;
    }
    
    #wrong-note.visible { opacity: 1; }
    
    #current-scale {
      top: 85px; left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      color: #0000ff;
      text-shadow: 0 0 10px #0000ff, 0 0 20px #0000ff, 2px 2px 0 #000;
    }
    
    #mic-status {
      top: 30px; right: 30px;
      font-family: 'Syne Mono', monospace;
      font-size: 14px;
      color: rgba(255,255,255,0.4);
    }
    
    #mic-status.connected {
      color: #f80;
      text-shadow: 0 0 10px #f80;
    }
    
    #audio-visualizer {
      position: fixed;
      bottom: 100px;
      right: 30px;
      width: 240px;
      height: 130px;
      background: rgba(0,0,0,0.8);
      border: 2px solid rgba(255,136,0,0.6);
      z-index: 200;
      overflow: hidden;
    }
    
    #audio-visualizer canvas {
      width: 100%;
      height: 100%;
    }
    
    #health-bar {
      position: fixed;
      bottom: 30px; left: 50%;
      transform: translateX(-50%);
      width: 400px; height: 30px;
      background: rgba(0,0,0,0.7);
      border: 3px solid #f36;
      box-shadow: 0 0 15px #f36, inset 0 0 15px rgba(255,51,102,0.3);
      z-index: 200;
    }
    
    #health-fill {
      height: 100%;
      background: linear-gradient(90deg, #f36, #f69);
      box-shadow: 0 0 20px #f36;
      transition: width 0.2s;
    }
    
    #health-label {
      bottom: 68px; left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: #f36;
      text-shadow: 0 0 10px #f36, 2px 2px 0 #000;
    }
    
    #beat-indicator {
      position: fixed;
      bottom: 100px; left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 200;
    }
    
    .beat-dot {
      width: 18px; height: 18px;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.05s;
    }
    
    .beat-dot.active {
      background: #fc0;
      box-shadow: 0 0 20px #fc0, 0 0 40px #f80;
      transform: scale(1.4);
    }
    
    #bottom-right-div {
      position: fixed;
      bottom: 30px; right: 30px;
    }

    #pause-btn {
      font-family: 'Syne Mono', monospace;
      font-size: 14px;
      padding: 10px;
      background: rgba(0,0,0,0.7);
      border: 2px solid rgba(255,255,255,0.8);
      color: white;
      cursor: pointer;
      z-index: 200;
      transition: all 0.2s;
    }
    
    #pause-btn:hover {
      border-color: #fc0;
      color: #fc0;
      text-shadow: 0 0 10px #fc0;
    }
    
    .screen-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 500;
      text-align: center;
    }
    
    .screen-overlay.visible { display: flex; }
    
    .screen-overlay h1 {
      font-family: 'Syne Mono', monospace;
      font-size: 56px;
      text-shadow: 0 0 20px currentColor, 4px 4px 0 #000;
      margin-bottom: 30px;
    }
    
    #start-screen h1 {
      color: #f36;
      animation: pulse 1s ease-in-out infinite alternate;
    }
    
    .instructions {
      font-family: 'Syne Mono', monospace;
      font-size: 16px;
      line-height: 2;
      margin-bottom: 30px;
      text-shadow: 2px 2px 0 #000;
    }
    
    .instructions .mic-info {
      color: #f80;
      text-shadow: 0 0 10px #f80, 2px 2px 0 #000;
    }
    
    #game-over-screen h1 { color: #f00; }
    #pause-screen { z-index: 450; }
    #pause-screen h1 { color: #fc0; font-size: 40px; }
    
    .score-text {
      font-family: 'Syne Mono', monospace;
      text-shadow: 0 0 15px currentColor, 2px 2px 0 #000;
      margin-bottom: 20px;
    }
    
    #final-score { font-size: 28px; color: #fc0; }
    #high-score { font-size: 22px; color: #0fc; margin-bottom: 50px; }
    
    .game-btn {
      font-family: 'Syne Mono', monospace;
      font-size: 22px;
      padding: 25px 50px;
      background: transparent;
      border: 3px solid #f80;
      color: #f80;
      cursor: pointer;
      text-shadow: 0 0 10px #f80;
      box-shadow: 0 0 20px rgba(255,136,0,0.3);
      transition: all 0.2s;
      margin: 10px;
    }
    
    .game-btn:hover {
      background: #f80;
      color: #000;
      box-shadow: 0 0 40px rgba(255,136,0,0.6);
    }
    
    #resume-btn { border-color: #0fc; color: #0fc; text-shadow: 0 0 10px #0fc; box-shadow: 0 0 20px rgba(0,255,204,0.3); }
    #resume-btn:hover { background: #0fc; box-shadow: 0 0 40px rgba(0,255,204,0.6); }
    
    .damage-text {
      position: absolute;
      font-family: 'Syne Mono', monospace;
      font-size: clamp(14px, 3vw, 22px);
      pointer-events: none;
      z-index: 300;
      animation: floatUp 0.8s ease-out forwards;
    }
    
    @keyframes pulse {
      from { text-shadow: 0 0 30px #f36, 0 0 60px #f36, 4px 4px 0 #000; }
      to { text-shadow: 0 0 50px #f69, 0 0 80px #f36, 4px 4px 0 #000; }
    }
    
    @keyframes floatUp {
      to { opacity: 0; transform: translateY(-180px) scale(1.5); }
    }
    
    .flash { animation: flash 2s ease-out; }
    @keyframes flash {
      0% { color: #fc0; transform: translateX(-50%) scale(1.3); }
      50% { color: #f0f; transform: translateX(-50%) scale(1.2); }
      100% { transform: translateX(-50%) scale(1); }
    }
    
    .milestone { animation: milestone 0.4s ease-out; }
    @keyframes milestone {
      0% { color: #fff; transform: scale(1.4); }
      100% { color: #f0f; transform: scale(1); }
    }

    @media (max-width: 768px) {
      #score-display { top: 15px; left: 15px; font-size: 18px; }
      #wave-display { top: 15px; font-size: 28px; }
      #combo-display { top: 42px; left: 15px; font-size: 18px; }
      #wrong-note { top: 70px; left: 15px; font-size: 18px; }
      #current-scale { top: 50px; font-size: 20px; }
      #mic-status { font-size: 11px; right: 15px; top: 15px; }
      #health-bar { width: 250px; height: 22px; bottom: 20px; }
      #health-label { bottom: 48px; font-size: 12px; }
      #beat-indicator { bottom: 70px; gap: 10px; }
      .beat-dot { width: 12px; height: 12px; }
      #audio-visualizer { width: 180px; height: 100px; bottom: 70px; right: 15px; }
      #bottom-right-div { bottom: 15px; right: 15px; }
      #pause-btn { font-size: 12px; padding: 8px; }
      .screen-overlay h1 { font-size: 36px; margin-bottom: 20px; }
      .instructions { font-size: 13px; line-height: 1.8; padding: 0 20px; }
      .game-btn { font-size: 16px; padding: 18px 30px; }
      #final-score { font-size: 22px; }
      #high-score { font-size: 18px; margin-bottom: 30px; }
    }

    @media (max-width: 480px) {
      #score-display { top: 10px; left: 10px; font-size: 14px; }
      #wave-display { top: 10px; font-size: 22px; }
      #combo-display { top: 32px; left: 10px; font-size: 14px; }
      #wrong-note { top: 54px; left: 10px; font-size: 14px; }
      #current-scale { top: 38px; font-size: 16px; }
      #mic-status { font-size: 9px; right: 10px; }
      #health-bar { width: 180px; height: 18px; bottom: 15px; }
      #health-label { bottom: 38px; font-size: 10px; }
      #beat-indicator { bottom: 55px; gap: 8px; }
      .beat-dot { width: 10px; height: 10px; }
      #audio-visualizer { width: 140px; height: 80px; bottom: 55px; right: 10px; }
      .screen-overlay h1 { font-size: 28px; }
      .instructions { font-size: 12px; padding: 0 15px; }
      .game-btn { font-size: 14px; padding: 15px 25px; }
    }
  </style>
</head>
<body>
  <div id="game-container"><canvas id="game"></canvas></div>
  <div id="vignette"></div>
  
  <div id="score-display" class="ui-text">SCORE: 0</div>
  <div id="wave-display" class="ui-text">WAVE 1</div>
  <div id="combo-display" class="ui-text">COMBO x1</div>
  <div id="wrong-note" class="ui-text">WRONG NOTE!</div>
  <div id="current-scale" class="ui-text">â™ª E STANDARD</div>
  <div id="mic-status" class="ui-text">MIC OFF</div>
  <div id="health-label" class="ui-text">â™¥ HEALTH â™¥</div>
  <div id="health-bar"><div id="health-fill"></div></div>
  
  <div id="audio-visualizer"><canvas id="viz-canvas"></canvas></div>
  
  <div id="beat-indicator">
    <div class="beat-dot"></div><div class="beat-dot"></div>
    <div class="beat-dot"></div><div class="beat-dot"></div>
  </div>
  
  <div id="bottom-right-div">
    <button id="pause-btn">âšâš PAUSE</button>
  </div>

  <div id="pause-screen" class="screen-overlay">
    <h1>PAUSED</h1>
    <button id="resume-btn" class="game-btn">â–º RESUME</button>
  </div>
  
  <div id="start-screen" class="screen-overlay visible">
    <h1>BASS SURVIVOR</h1>
    <div class="instructions">
      PLAY NOTES ON YOUR BASS TO KILL MONSTERS<br>
      ACCURACY COMBO STREAKS GIVE HIGHER SCORES<br>
      <span class="mic-info">LATER WAVES: CHORD MONSTERS REQUIRE ROOT + 3RD!</span>
    </div>
    <button id="start-btn" class="game-btn">ğŸ¸ START GAME</button>
  </div>

  <div id="game-over-screen" class="screen-overlay">
    <h1>GAME OVER</h1>
    <div id="final-score" class="score-text">SCORE: 0</div>
    <div id="high-score" class="score-text">HIGH SCORE: 0</div>
    <button id="restart-btn" class="game-btn">â–º TRY AGAIN</button>
  </div>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTANTS & DATA - BASS FOCUSED
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const NOTE_NAMES = {
      sharp: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
      flat: ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
    };
    
    // Bass-focused scales (lower octaves)
    const SCALES = {
      'E STANDARD':   { root: 4, intervals: [0,2,4,5,7,9,11], flats: false },
      'E MINOR':      { root: 4, intervals: [0,2,3,5,7,8,10], flats: false },
      'A MINOR':      { root: 9, intervals: [0,2,3,5,7,8,10], flats: false },
      'G MAJOR':      { root: 7, intervals: [0,2,4,5,7,9,11], flats: false },
      'D MAJOR':      { root: 2, intervals: [0,2,4,5,7,9,11], flats: false },
      'C MAJOR':      { root: 0, intervals: [0,2,4,5,7,9,11], flats: false },
      'A PENTATONIC': { root: 9, intervals: [0,3,5,7,10], flats: false },
      'E PENTATONIC': { root: 4, intervals: [0,3,5,7,10], flats: false },
      'BLUES':        { root: 4, intervals: [0,3,5,6,7,10], flats: false },
    };
    
    const SCALE_NAMES = Object.keys(SCALES);
    
    // Chord quality based on interval from root to 3rd
    // Major 3rd = 4 semitones, Minor 3rd = 3 semitones
    const CHORD_QUALITIES = {
      4: '', // Major (no suffix)
      3: 'm', // Minor
    };
    
    const NOTE_COLORS = {
      C: '#ff3366', 'C#': '#ff5588', Db: '#ff5588', D: '#ff8800', 'D#': '#ffaa33', Eb: '#ffaa33',
      E: '#ffcc00', F: '#88ff00', 'F#': '#66cc00', Gb: '#66cc00', G: '#00ffcc', 'G#': '#00ccaa', Ab: '#00ccaa',
      A: '#0088ff', 'A#': '#3366ff', Bb: '#3366ff', B: '#aa00ff'
    };
    
    // Sprite data: 12x12 pixel art for each note
    const SPRITES = {
      C: [[0,0,0,1,0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0,1,1,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,0,1,1,1,1,0,1,1,0],[1,1,1,0,1,1,1,1,0,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,0,0,1,1,1,1,1],[0,1,1,1,0,0,0,0,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0,1,1,0,0]],
      'C#': [[0,0,1,0,0,0,0,0,0,1,0,0],[0,1,1,0,0,0,0,0,0,1,1,0],[1,1,1,0,0,1,1,0,0,1,1,1],[1,1,1,0,1,1,1,1,0,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,0,0,1,1,1,1,1],[1,1,1,1,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,0,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0]],
      D: [[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,0,0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,0,0,1,1,1,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,0,1,1,0,1,0,0,0],[0,0,0,1,0,1,1,0,1,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,1,0,0,0,0,0]],
      'D#': [[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,0,1,1,0,0,1,1,0,1,0],[0,1,0,1,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0]],
      E: [[0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,1,0,1,1,0,1,1,1,0],[0,1,1,1,0,1,1,0,1,1,1,0],[1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,0,1,1,1,1,0,0,0,0]],
      F: [[0,1,0,0,0,0,0,0,0,0,1,0],[1,0,1,0,0,0,0,0,0,1,0,1],[0,1,0,1,0,1,1,0,1,0,1,0],[0,0,1,0,1,1,1,1,0,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,0,1,1,0,1,1,0,0],[0,1,0,1,0,1,1,0,1,0,1,0],[1,0,0,1,1,1,1,1,1,0,0,1],[0,1,0,0,1,1,1,1,0,0,1,0],[0,0,1,0,0,1,1,0,0,1,0,0],[0,0,0,1,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,1,0,0,0,0]],
      'F#': [[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,0,0,0,0,1,1,1,0],[1,1,1,0,0,1,1,0,0,1,1,1],[1,1,1,0,1,1,1,1,0,1,1,1],[1,1,1,0,1,1,1,1,0,1,1,1],[1,1,1,0,0,1,1,0,0,1,1,1],[0,1,1,1,0,0,0,0,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0]],
      G: [[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[1,1,0,0,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,0,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,1],[0,1,1,1,1,0,0,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,0,1,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,0,0,1,0,0]],
      'G#': [[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,0,1,1,0,1,1,0,0],[0,1,1,1,0,1,1,0,1,1,1,0],[1,1,0,1,1,1,1,1,1,0,1,1],[1,1,0,1,1,1,1,1,1,0,1,1],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,1,1,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,1,1,0,0,0],[0,0,1,1,1,1,1,1,1,1,0,0]],
      A: [[0,0,1,1,1,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,0,0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,0,0,0,0,1,1,0,0],[1,1,1,1,1,1,1,1,1,1,1,1],[1,0,1,1,1,1,1,1,1,1,0,1],[1,0,1,1,1,1,1,1,1,1,0,1],[0,0,1,1,0,0,0,0,1,1,0,0],[0,0,1,1,0,0,0,0,1,1,0,0],[0,1,1,1,0,0,0,0,1,1,1,0]],
      'A#': [[0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,1,1,0,1,1,0,1,1,0,0],[0,0,1,1,0,1,1,0,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,0,0,1,1,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[1,0,0,1,1,1,1,1,1,0,0,1],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,1,1,0,0,1,1,0,0,0]],
      B: [[0,1,0,0,0,0,0,0,0,0,1,0],[1,1,0,0,0,0,0,0,0,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,1],[0,1,1,0,1,1,1,1,0,1,1,0],[0,1,1,0,1,1,1,1,0,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,1,1,1,0,0,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,1,0,1,1,0,1,0,0,0],[0,0,1,0,0,1,1,0,0,1,0,0],[0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0]]
    };
    
    const SPRITE_MAP = { Db:'C#', Eb:'D#', Gb:'F#', Ab:'G#', Bb:'A#' };
    
    // Bass guitar sprite
    const BASS_SPRITE = [
      [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
      [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
      [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
      [1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0],
      [1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0],
      [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
      [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
      [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
      [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0]
    ];
    
    const A4_FREQ = 440;
    const A4_MIDI = 69;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const $ = id => document.getElementById(id);
    const canvas = $('game');
    const ctx = canvas.getContext('2d');

    const getUIScale = () => Math.min(1, Math.max(0.6, canvas.width / 800));
    
    let state = {
      running: false, paused: false, waveTransition: false,
      score: 0, combo: 0, maxCombo: 0, health: 100, wave: 1,
      scale: 'E STANDARD', bpm: 80,
      enemies: [], particles: [], lightning: [],
      lastBeat: 0, beatCount: 0, lastSpawn: 0, waveRemaining: 0,
      shake: 0, heldNotes: new Set()
    };
    
    let player = { x: 0, y: 0, targetAngle: -Math.PI/2, currentAngle: -Math.PI/2 };
    let audioCtx, wrongNoteTimeout;
    
    // Load bass image
    let bassImage = new Image();
    bassImage.src = 'bass-icon.webp';
    let bassImageLoaded = false;
    bassImage.onload = () => { bassImageLoaded = true; };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MICROPHONE STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let micState = {
      enabled: false,
      stream: null,
      source: null,
      analyzer: null,
      lastDetectedNote: null,
      lastDetectedTime: 0,
      rms: 0,
      minRmsThreshold: 0.02,
      minCorrelation: 0.5,
      noteDebounceTime: 100,
      noteOffDebounceTime: 300,
      vizCanvas: null,
      vizCtx: null,
      pitchHistory: [],
      pitchHistorySize: 3,
      lastConfidence: 0,
      displayNote: '--',
      displayFreq: 0
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const hypot = (x, y) => Math.sqrt(x*x + y*y);
    const rand = (min=0, max=1) => Math.random() * (max - min) + min;
    const pick = arr => arr[Math.floor(Math.random() * arr.length)];
    
    function adjustColor(hex, amount) {
      const clamp = v => Math.max(0, Math.min(255, v));
      const r = parseInt(hex.slice(1,3), 16);
      const g = parseInt(hex.slice(3,5), 16);
      const b = parseInt(hex.slice(5,7), 16);
      const adj = amount > 0 
        ? v => clamp(v + (255-v) * amount)
        : v => clamp(v * (1 + amount));
      return `rgb(${adj(r)},${adj(g)},${adj(b)})`;
    }
    
    function flashElement(el, cls='flash') {
      el.classList.remove(cls);
      void el.offsetWidth;
      el.classList.add(cls);
    }
    
    function drawSprite(sprite, x, y, size, color, darkColor) {
      if (!sprite || !sprite.length) return;
      const len = sprite.length;
      const offset = (len * size) / 2;
      for (let r = 0; r < len; r++) {
        for (let c = 0; c < sprite[r].length; c++) {
          if (sprite[r][c]) {
            const isEdge = r === 0 || c === 0 || r === len-1 || c === sprite[r].length-1 ||
              (r > 0 && !sprite[r-1][c]) || (c > 0 && !sprite[r][c-1]);
            ctx.fillStyle = isEdge ? darkColor : color;
            ctx.fillRect(x - offset + c*size, y - offset + r*size, size, size);
          }
        }
      }
    }
    
    function freqToMidi(freq) {
      if (freq <= 0) return null;
      return Math.round(12 * Math.log2(freq / A4_FREQ) + A4_MIDI);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUDIO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function playTone(freq, type, vol, dur) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      osc.type = type;
      gain.gain.setValueAtTime(vol, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    }
    
    const playHit = midi => playTone(440 * Math.pow(2, (midi-69)/12), 'triangle', 0.3, 0.15);
    const playMiss = () => playTone(80, 'sawtooth', 0.1, 0.1);
    const playBeat = () => playTone(60, 'sine', 0.2, 0.08);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PITCH DETECTION (YIN-INSPIRED)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function autoCorrelate(buffer, sampleRate) {
      const SIZE = buffer.length;
      
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / SIZE);
      micState.rms = rms;
      
      if (rms < micState.minRmsThreshold) {
        micState.lastConfidence = 0;
        return { frequency: -1, confidence: 0 };
      }
      
      const yinBufferSize = Math.floor(SIZE / 2);
      const yinBuffer = new Float32Array(yinBufferSize);
      
      for (let tau = 0; tau < yinBufferSize; tau++) {
        yinBuffer[tau] = 0;
        for (let i = 0; i < yinBufferSize; i++) {
          const delta = buffer[i] - buffer[i + tau];
          yinBuffer[tau] += delta * delta;
        }
      }
      
      yinBuffer[0] = 1;
      let runningSum = 0;
      for (let tau = 1; tau < yinBufferSize; tau++) {
        runningSum += yinBuffer[tau];
        yinBuffer[tau] *= tau / runningSum;
      }
      
      const yinThreshold = 0.4;
      let tauEstimate = -1;
      
      for (let tau = 2; tau < yinBufferSize; tau++) {
        if (yinBuffer[tau] < yinThreshold) {
          while (tau + 1 < yinBufferSize && yinBuffer[tau + 1] < yinBuffer[tau]) {
            tau++;
          }
          tauEstimate = tau;
          break;
        }
      }
      
      if (tauEstimate === -1) {
        micState.lastConfidence = 0;
        return { frequency: -1, confidence: 0 };
      }
      
      let betterTau = tauEstimate;
      if (tauEstimate > 0 && tauEstimate < yinBufferSize - 1) {
        const s0 = yinBuffer[tauEstimate - 1];
        const s1 = yinBuffer[tauEstimate];
        const s2 = yinBuffer[tauEstimate + 1];
        betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
      }
      
      const frequency = sampleRate / betterTau;
      const confidence = 1 - yinBuffer[tauEstimate];
      micState.lastConfidence = confidence;
      
      if (frequency < 30 || frequency > 400) {
        return { frequency: -1, confidence: 0 };
      }
      
      if (confidence < micState.minCorrelation) {
        return { frequency: -1, confidence: confidence };
      }
      
      return { frequency, confidence };
    }
    
    function isPitchStable(midi) {
      micState.pitchHistory.push(midi);
      
      if (micState.pitchHistory.length > micState.pitchHistorySize) {
        micState.pitchHistory.shift();
      }
      
      if (micState.pitchHistory.length < micState.pitchHistorySize) {
        return false;
      }
      
      const target = micState.pitchHistory[micState.pitchHistory.length - 1];
      for (let i = 0; i < micState.pitchHistory.length - 1; i++) {
        if (Math.abs(micState.pitchHistory[i] - target) > 1) {
          return false;
        }
      }
      
      return true;
    }
    
    function clearPitchHistory() {
      micState.pitchHistory = [];
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MICROPHONE SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async function setupMicrophone() {
      try {
        micState.stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: true,
            channelCount: 1,
            sampleRate: 44100
          }, 
          video: false 
        });
        
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        
        micState.source = audioCtx.createMediaStreamSource(micState.stream);
        micState.analyzer = audioCtx.createAnalyser();
        micState.analyzer.fftSize = 4096;
        micState.analyzer.smoothingTimeConstant = 0.1;
        micState.source.connect(micState.analyzer);
        
        $('mic-status').textContent = 'MIC ACTIVE';
        $('mic-status').classList.add('connected');
        $('audio-visualizer').style.display = 'block';

        micState.vizCanvas = $('viz-canvas');
        micState.vizCtx = micState.vizCanvas.getContext('2d');
        const vizRect = $('audio-visualizer').getBoundingClientRect();
        micState.vizCanvas.width = vizRect.width || 240;
        micState.vizCanvas.height = vizRect.height || 130;

        micState.enabled = true;
        detectPitch();
        
        return true;
        
      } catch (err) {
        console.error('Microphone access denied:', err);
        $('mic-status').textContent = 'MIC DENIED';
        alert('Microphone access was denied. Please allow microphone access and try again.');
        return false;
      }
    }
    
    function stopMicrophone() {
      if (micState.stream) {
        micState.stream.getTracks().forEach(track => track.stop());
      }
      micState.enabled = false;
      micState.stream = null;
      micState.source = null;
      $('mic-status').textContent = 'MIC OFF';
      $('mic-status').classList.remove('connected');
    }
    
    function detectPitch() {
      if (!micState.enabled) return;
      
      drawAudioVisualization();
      
      if (!state.running || state.paused) {
        requestAnimationFrame(detectPitch);
        return;
      }
      
      const bufferLength = micState.analyzer.fftSize;
      const buffer = new Float32Array(bufferLength);
      micState.analyzer.getFloatTimeDomainData(buffer);
      
      const result = autoCorrelate(buffer, audioCtx.sampleRate);
      const frequency = result.frequency;
      const confidence = result.confidence;
      
      const now = performance.now();
      
      if (frequency > 30 && frequency < 400 && confidence >= micState.minCorrelation) {
        const midi = freqToMidi(frequency);
        const noteName = NOTE_NAMES.sharp[midi % 12];
        
        micState.displayNote = noteName;
        micState.displayFreq = frequency;
        
        if (isPitchStable(midi)) {
          if (midi !== micState.lastDetectedNote || 
              now - micState.lastDetectedTime > micState.noteDebounceTime) {
            
            if (micState.lastDetectedNote !== null && midi !== micState.lastDetectedNote) {
              onNoteOff(micState.lastDetectedNote);
            }
            
            if (midi !== micState.lastDetectedNote) {
              onNoteOn(midi);
            }
            
            micState.lastDetectedNote = midi;
            micState.lastDetectedTime = now;
          }
        }
      } else {
        clearPitchHistory();
        micState.displayNote = '--';
        micState.displayFreq = 0;
        
        if (micState.lastDetectedNote !== null && 
            now - micState.lastDetectedTime > micState.noteOffDebounceTime) {
          onNoteOff(micState.lastDetectedNote);
          micState.lastDetectedNote = null;
        }
      }
      
      requestAnimationFrame(detectPitch);
    }
    
    function drawAudioVisualization() {
      if (!micState.vizCtx) return;

      const ctx = micState.vizCtx;
      const width = micState.vizCanvas.width;
      const height = micState.vizCanvas.height;

      ctx.fillStyle = 'rgba(10, 15, 25, 0.95)';
      ctx.fillRect(0, 0, width, height);

      const scale = Math.min(1, width / 240);
      const noteAreaWidth = Math.round(80 * scale);
      const barsWidth = Math.round(35 * scale);
      const waveAreaWidth = width - noteAreaWidth - barsWidth - Math.round(10 * scale);
      
      const isNoteDetected = micState.displayNote !== '--';
      const noteColor = isNoteDetected ? (NOTE_COLORS[micState.displayNote] || '#fff') : '#333';
      
      if (isNoteDetected) {
        const gradient = ctx.createRadialGradient(noteAreaWidth/2, height/2, 0, noteAreaWidth/2, height/2, 50);
        gradient.addColorStop(0, noteColor + '40');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, noteAreaWidth, height);
      }
      
      ctx.font = `bold ${Math.round(42 * scale)}px "Syne Mono"`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = noteColor;
      if (isNoteDetected) {
        ctx.shadowColor = noteColor;
        ctx.shadowBlur = 18 * scale;
      }
      ctx.fillText(micState.displayNote, noteAreaWidth/2, height/2 - 8 * scale);
      ctx.shadowBlur = 0;

      ctx.font = `${Math.round(12 * scale)}px "Syne Mono"`;
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      if (micState.displayFreq > 0) {
        ctx.fillText(Math.round(micState.displayFreq) + ' Hz', noteAreaWidth/2, height/2 + 24 * scale);
      }
      
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.beginPath();
      ctx.moveTo(noteAreaWidth, 10);
      ctx.lineTo(noteAreaWidth, height - 10);
      ctx.stroke();
      
      if (micState.analyzer) {
        const bufferLength = micState.analyzer.fftSize;
        const dataArray = new Float32Array(bufferLength);
        micState.analyzer.getFloatTimeDomainData(dataArray);
        
        ctx.strokeStyle = isNoteDetected ? noteColor : '#0f8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const waveStartX = noteAreaWidth + 8;
        const sliceWidth = waveAreaWidth / 180;
        let x = waveStartX;
        
        for (let i = 0; i < 180; i++) {
          const sampleIndex = Math.floor(i * bufferLength / 180);
          const v = dataArray[sampleIndex];
          const y = (v + 1) / 2 * height;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          x += sliceWidth;
        }
        ctx.stroke();
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(waveStartX, height / 2);
        ctx.lineTo(waveStartX + waveAreaWidth, height / 2);
        ctx.stroke();
      }
      
      const barWidth = Math.round(10 * scale);
      const barGap = Math.round(5 * scale);
      const barsStartX = width - Math.round(28 * scale);
      const barTop = Math.round(20 * scale);
      const barHeight = height - Math.round(28 * scale);
      
      const volX = barsStartX;
      const volFillHeight = Math.min(barHeight, micState.rms * barHeight * 10);
      const isAboveVolThreshold = micState.rms >= micState.minRmsThreshold;
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(volX, barTop, barWidth, barHeight);
      
      ctx.fillStyle = isAboveVolThreshold ? '#0f8' : '#444';
      ctx.fillRect(volX, barTop + barHeight - volFillHeight, barWidth, volFillHeight);
      
      const volThreshY = barTop + barHeight - (micState.minRmsThreshold * barHeight * 10);
      ctx.fillStyle = '#f80';
      ctx.fillRect(volX - 2 * scale, volThreshY - 1, barWidth + 4 * scale, Math.max(2, 2 * scale));
      
      const confX = barsStartX + barWidth + barGap;
      const confFillHeight = Math.min(barHeight, micState.lastConfidence * barHeight);
      const isAboveConfThreshold = micState.lastConfidence >= micState.minCorrelation;
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(confX, barTop, barWidth, barHeight);
      
      ctx.fillStyle = isAboveConfThreshold ? '#fc0' : '#444';
      ctx.fillRect(confX, barTop + barHeight - confFillHeight, barWidth, confFillHeight);
      
      const confThreshY = barTop + barHeight - (micState.minCorrelation * barHeight);
      ctx.fillStyle = '#f0f';
      ctx.fillRect(confX - 2 * scale, confThreshY - 1, barWidth + 4 * scale, Math.max(2, 2 * scale));

      ctx.font = `${Math.round(10 * scale)}px "Syne Mono"`;
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillText('V', volX + barWidth/2, Math.round(12 * scale));
      ctx.fillText('C', confX + barWidth/2, Math.round(12 * scale));
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PARTICLES & EFFECTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function spawnParticles(x, y, color, count, speedRange, decay) {
      for (let i = 0; i < count; i++) {
        const angle = rand(0, Math.PI * 2);
        const speed = rand(...speedRange);
        state.particles.push({
          x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
          life: 1, decay, size: rand(4, 12), color
        });
      }
    }
    
    function spawnLightning(targetX, targetY) {
      const points = [{x: player.x, y: player.y}];
      const dx = targetX - player.x;
      const dy = targetY - player.y;
      const dist = hypot(dx, dy);
      
      // Update player's target angle (headstock points toward target)
      // atan2 gives angle from positive x-axis, we want top of bass to point at target
      player.targetAngle = Math.atan2(dy, dx) + Math.PI/2;
      const segments = Math.floor(dist / 30) + 3;
      
      for (let i = 1; i < segments; i++) {
        const t = i / segments;
        const baseX = player.x + dx * t;
        const baseY = player.y + dy * t;
        const perpX = -dy / dist;
        const perpY = dx / dist;
        const offset = (Math.random() - 0.5) * 80 * (1 - Math.abs(t - 0.5) * 2);
        points.push({
          x: baseX + perpX * offset,
          y: baseY + perpY * offset
        });
      }
      points.push({x: targetX, y: targetY});
      
      state.lightning.push({
        points,
        life: 1,
        decay: 0.04
      });
    }
    
    function spawnDamageText(x, y, text, color) {
      const el = document.createElement('div');
      el.className = 'damage-text';
      el.style.cssText = `left:${x}px;top:${y}px;color:${color};text-shadow:0 0 10px ${color}`;
      el.textContent = text;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 800);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCALE & ENEMY MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function getScaleNotes() {
      const scale = SCALES[state.scale];
      const names = NOTE_NAMES[scale.flats ? 'flat' : 'sharp'];
      const notes = [];
      for (let oct = 1; oct <= 3; oct++) {
        for (const interval of scale.intervals) {
          notes.push({
            midi: (oct + 1) * 12 + scale.root + interval,
            name: names[(scale.root + interval) % 12],
            octave: oct
          });
        }
      }
      return notes;
    }
    
    // Generate a chord (root + 3rd) from the current scale
    function generateChord() {
      const scale = SCALES[state.scale];
      const names = NOTE_NAMES[scale.flats ? 'flat' : 'sharp'];
      const intervals = scale.intervals;
      
      // Pick a random scale degree as root (0-indexed position in scale)
      const rootDegree = Math.floor(rand(0, intervals.length));
      const thirdDegree = (rootDegree + 2) % intervals.length; // 3rd is 2 scale degrees up
      
      const baseOctave = Math.floor(rand(1, 3));
      
      // Calculate MIDI notes
      const rootInterval = intervals[rootDegree];
      const thirdInterval = intervals[thirdDegree];
      
      const rootMidi = (baseOctave + 1) * 12 + scale.root + rootInterval;
      let thirdMidi = (baseOctave + 1) * 12 + scale.root + thirdInterval;
      
      // If third is lower than root (wrapped around), bump it up an octave
      if (thirdMidi <= rootMidi) {
        thirdMidi += 12;
      }
      
      const rootName = names[(scale.root + rootInterval) % 12];
      const thirdName = names[(scale.root + thirdInterval) % 12];
      
      // Determine chord quality (major or minor) based on interval
      const semitones = thirdMidi - rootMidi;
      const quality = CHORD_QUALITIES[semitones] || '';
      const chordName = rootName + quality;
      
      return {
        chordName,
        notes: [
          { name: rootName, midi: rootMidi, hit: false },
          { name: thirdName, midi: thirdMidi, hit: false }
        ]
      };
    }
    
    function spawnEnemy() {
      if (state.waveRemaining <= 0) return;

      const side = Math.floor(rand(0, 4));
      const margin = 50;
      const speed = 0.35 + state.wave * 0.08 + rand(0, 0.2);

      let x, y;
      if (side === 0) { x = rand(0, canvas.width); y = -margin; }
      else if (side === 1) { x = canvas.width + margin; y = rand(0, canvas.height); }
      else if (side === 2) { x = rand(0, canvas.width); y = canvas.height + margin; }
      else { x = -margin; y = rand(0, canvas.height); }

      // Determine enemy type: chord enemies start appearing at wave 4
      let type = 'normal';
      if (state.wave >= 4) {
        // Increasing chance of chord enemies as waves progress
        const chordChance = Math.min(0.4, 0.15 + (state.wave - 4) * 0.05);
        if (rand() < chordChance) {
          type = 'chord';
        } else if (rand() < 0.2) {
          type = 'fast';
        }
      } else if (state.wave >= 2 && rand() < 0.15) {
        type = 'fast';
      }

      if (type === 'chord') {
        const chord = generateChord();
        state.enemies.push({
          x, y,
          type: 'chord',
          chordName: chord.chordName,
          notes: chord.notes,
          note: chord.notes[0].name, // Primary note for color
          speed: speed * 0.7, // Chord enemies are slower
          size: 50,
          health: 1,
          color: NOTE_COLORS[chord.notes[0].name],
          pulsePhase: rand(0, Math.PI * 2),
          chordProgress: 0,
          chordWindowMs: 1500, // Time window to complete chord
          chordStartTime: null
        });
      } else {
        const noteData = pick(getScaleNotes());
        state.enemies.push({
          x, y,
          type,
          note: noteData.name,
          midi: noteData.midi,
          octave: noteData.octave,
          speed: type === 'fast' ? speed * 1.8 : speed,
          size: 40,
          health: 1,
          color: NOTE_COLORS[noteData.name],
          pulsePhase: rand(0, Math.PI * 2)
        });
      }

      state.waveRemaining--;
    }
    
    function startWave() {
      let newScale;
      do { newScale = pick(SCALE_NAMES); } while (newScale === state.scale && SCALE_NAMES.length > 1);
      state.scale = newScale;
      state.bpm = Math.min(160, 70 + state.wave * 4);
      state.waveRemaining = 3 + state.wave * 2;
      
      $('current-scale').textContent = 'â™ª ' + state.scale;
      $('wave-display').textContent = `WAVE ${state.wave}`;
      flashElement($('current-scale'));
      flashElement($('wave-display'));
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INPUT HANDLING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function getNoteNames(midi) {
      return [NOTE_NAMES.sharp[midi % 12], NOTE_NAMES.flat[midi % 12]];
    }
    
    function showWrongNote() {
      $('wrong-note').classList.add('visible');
      clearTimeout(wrongNoteTimeout);
      wrongNoteTimeout = setTimeout(() => $('wrong-note').classList.remove('visible'), 500);
    }
    
    function onNoteOn(midi) {
      if (!state.running || state.paused) return;

      const [sharp, flat] = getNoteNames(midi);
      state.heldNotes.add(sharp).add(flat);

      // Check if note matches any enemy
      const onScreen = new Set();
      state.enemies.forEach(e => {
        if (e.type === 'chord' && e.notes) {
          e.notes.forEach(n => onScreen.add(n.name));
        } else {
          onScreen.add(e.note);
        }
      });

      if (!onScreen.has(sharp) && !onScreen.has(flat)) {
        state.combo = 0;
        showWrongNote();
        playMiss();
        state.shake = 8;
        updateUI();
        return;
      }

      // PRIORITY: Single note enemies first, then chord enemies
      
      // Check single-note enemies (normal and fast)
      const singleNoteEnemies = state.enemies
        .filter(e => (e.type === 'normal' || e.type === 'fast') && (e.note === sharp || e.note === flat))
        .sort((a, b) => hypot(a.x - player.x, a.y - player.y) - hypot(b.x - player.x, b.y - player.y));

      if (singleNoteEnemies.length > 0) {
        const enemy = singleNoteEnemies[0];
        checkComboMilestone(state.combo++);
        spawnParticles(enemy.x, enemy.y, enemy.color, 8, [3, 6], 0.03);
        playHit(midi);

        if (--enemy.health <= 0) {
          const mult = 1 + Math.floor(state.combo / 5) * 0.5;
          const pts = Math.floor((50 + state.wave * 10) * mult);
          state.score += pts;
          spawnLightning(enemy.x, enemy.y);
          spawnDamageText(enemy.x, enemy.y, `+${pts}`, '#fc0');
          spawnParticles(enemy.x, enemy.y, enemy.color, 20, [2, 8], 0.015);
          state.enemies = state.enemies.filter(e => e !== enemy);
          state.shake = 10;
        }
        state.maxCombo = Math.max(state.maxCombo, state.combo);
        updateUI();
        return;
      }

      // Check chord enemies
      const chordEnemies = state.enemies.filter(e =>
        e.type === 'chord' && e.notes &&
        e.notes.some(n => (n.name === sharp || n.name === flat) && !n.hit)
      );

      if (chordEnemies.length > 0) {
        // Prioritize chords already in progress, then by distance
        const enemy = chordEnemies.sort((a, b) => {
          if (a.chordProgress > 0 && b.chordProgress === 0) return -1;
          if (b.chordProgress > 0 && a.chordProgress === 0) return 1;
          return hypot(a.x - player.x, a.y - player.y) - hypot(b.x - player.x, b.y - player.y);
        })[0];

        // Mark the note as hit
        const hitNote = enemy.notes.find(n => (n.name === sharp || n.name === flat) && !n.hit);
        if (hitNote) {
          hitNote.hit = true;
          enemy.chordProgress++;
          playHit(midi);
          spawnParticles(enemy.x, enemy.y, NOTE_COLORS[hitNote.name], 8, [2, 5], 0.04);

          // Start chord window timer on first note
          if (enemy.chordProgress === 1) {
            enemy.chordStartTime = performance.now();
          }

          // Check if chord is complete
          if (enemy.notes.every(n => n.hit)) {
            checkComboMilestone(state.combo++);
            state.maxCombo = Math.max(state.maxCombo, state.combo);

            const mult = 1 + Math.floor(state.combo / 5) * 0.5;
            const pts = Math.floor((100 + state.wave * 15) * mult);
            state.score += pts;

            spawnLightning(enemy.x, enemy.y);
            spawnDamageText(enemy.x, enemy.y, `+${pts} ${enemy.chordName}!`, '#f0f');
            spawnParticles(enemy.x, enemy.y, enemy.color, 30, [3, 10], 0.012);
            state.enemies = state.enemies.filter(e => e !== enemy);
            state.shake = 15;
          }
        }
        updateUI();
        return;
      }

      updateUI();
    }
    
    function onNoteOff(midi) {
      if (!state.running) return;
      const [sharp, flat] = getNoteNames(midi);
      state.heldNotes.delete(sharp);
      state.heldNotes.delete(flat);
    }
    
    function checkComboMilestone(prev) {
      if (Math.floor((prev + 1) / 5) > Math.floor(prev / 5) && prev >= 4) {
        flashElement($('combo-display'), 'milestone');
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI & GAME FLOW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateUI() {
      $('score-display').textContent = `SCORE: ${state.score}`;
      $('health-fill').style.width = `${state.health}%`;
      const combo = $('combo-display');
      combo.textContent = `COMBO x${state.combo}`;
      combo.classList.toggle('active', state.combo > 1);
    }
    
    function resize() {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
    }
    
    function pause() {
      if (!state.running || state.paused) return;
      state.paused = true;
      $('pause-screen').classList.add('visible');
      $('bottom-right-div').style.display = 'none';
    }
    
    function resume() {
      if (!state.paused) return;
      state.paused = false;
      $('pause-screen').classList.remove('visible');
      $('bottom-right-div').style.display = 'block';
      state.lastBeat = performance.now();
      requestAnimationFrame(loop);
    }
    
    async function start() {
      $('start-screen').classList.remove('visible');
      
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      const micSuccess = await setupMicrophone();
      if (!micSuccess) {
        return;
      }
      
      Object.assign(state, {
        running: true, score: 0, combo: 0, health: 100, wave: 1,
        enemies: [], particles: [], lightning: [], lastBeat: performance.now(),
        waveTransition: false, waveRemaining: 0
      });
      state.heldNotes.clear();
      startWave();
      requestAnimationFrame(loop);
    }
    
    function gameOver() {
      state.running = false;
      stopMicrophone();
      const high = Math.max(state.score, parseInt(localStorage.getItem('bassSurvivorHighScore') || '0'));
      localStorage.setItem('bassSurvivorHighScore', high);
      $('final-score').textContent = `SCORE: ${state.score}`;
      $('high-score').textContent = `HIGH SCORE: ${high}`;
      $('game-over-screen').classList.add('visible');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let lastTime = 0;
    
    function loop(now) {
      if (!state.running || state.paused) return;
      
      const dt = now - lastTime;
      lastTime = now;
      
      update(dt, now);
      render();
      
      state.health > 0 ? requestAnimationFrame(loop) : gameOver();
    }
    
    function update(dt, now) {
      const beatInterval = 60000 / state.bpm;
      
      if (now - state.lastBeat >= beatInterval) {
        state.lastBeat = now - ((now - state.lastBeat) % beatInterval);
        state.beatCount = (state.beatCount + 1) % 4;
        playBeat();
        document.querySelectorAll('.beat-dot').forEach((d, i) => d.classList.toggle('active', i === state.beatCount));
      }
      
      state.lastSpawn += dt;
      const spawnInterval = Math.max(400, 1200 - state.wave * 50);
      if (state.lastSpawn > spawnInterval && state.waveRemaining > 0) {
        spawnEnemy();
        state.lastSpawn = 0;
      }

      // Update enemies
      state.enemies.forEach(e => {
        // Chord timeout check
        if (e.type === 'chord' && e.chordProgress > 0 && e.chordStartTime) {
          const elapsed = now - e.chordStartTime;
          if (elapsed > e.chordWindowMs) {
            // Chord timed out - reset progress
            e.notes.forEach(n => n.hit = false);
            e.chordProgress = 0;
            e.chordStartTime = null;
            state.combo = 0;
            showWrongNote();
            playMiss();
            state.shake = 8;
            spawnDamageText(e.x, e.y, 'TIMEOUT!', '#f00');
          }
        }

        const dx = player.x - e.x, dy = player.y - e.y;
        const dist = hypot(dx, dy);
        let speedMod = 1;
        if (e.type === 'chord' && e.chordProgress > 0) speedMod = 0.5;

        if (dist > 0) {
          e.x += (dx / dist) * e.speed * speedMod;
          e.y += (dy / dist) * e.speed * speedMod;
        }
        e.pulsePhase += 0.1;

        const sizeScale = Math.min(1, Math.max(0.7, canvas.width / 800));
        const collisionRadius = e.type === 'chord' ? e.size * sizeScale + 30 : e.size * sizeScale + 25;
        if (dist < collisionRadius) {
          const damage = e.type === 'chord' ? 15 : 10;
          state.health -= damage;
          state.shake = 20;
          spawnParticles(e.x, e.y, '#f00', 20, [2, 8], 0.015);
          e.health = 0;
        }
      });
      
      state.enemies = state.enemies.filter(e => e.health > 0);
      
      state.particles.forEach(p => {
        p.x += p.vx; p.y += p.vy;
        p.vx *= 0.95; p.vy *= 0.95;
        p.life -= p.decay;
      });
      state.particles = state.particles.filter(p => p.life > 0);
      
      state.lightning.forEach(l => l.life -= l.decay);
      state.lightning = state.lightning.filter(l => l.life > 0);
      
      if (state.shake > 0) state.shake *= 0.9;
      
      if (!state.waveTransition && state.waveRemaining <= 0 && state.enemies.length === 0) {
        state.waveTransition = true;
        state.wave++;
        setTimeout(() => {
          startWave();
          state.waveTransition = false;
        }, 2000);
      }
      
      updateUI();
    }
    
    function render() {
      ctx.save();
      if (state.shake > 0.5) ctx.translate(rand(-1, 1) * state.shake, rand(-1, 1) * state.shake);
      
      ctx.fillStyle = '#0a1628';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const gridSpacing = Math.max(30, Math.min(50, canvas.width / 16));
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
      for (let x = 0; x < canvas.width; x += gridSpacing) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gridSpacing) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
      }
      
      // Smoothly interpolate bass rotation toward target
      const angleDiff = player.targetAngle - player.currentAngle;
      // Normalize angle difference to [-PI, PI]
      const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
      player.currentAngle += normalizedDiff * 0.15; // Smooth rotation speed
      
      // Bass guitar (player) - using custom image with dynamic rotation
      const bassScale = getUIScale();
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.currentAngle);
      
      const glowRadius = 100 * bassScale;
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
      grad.addColorStop(0, 'rgba(255,136,0,0.5)');
      grad.addColorStop(0.4, 'rgba(255,136,0,0.2)');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(0, 0, glowRadius, 0, Math.PI * 2); ctx.fill();
      
      if (bassImageLoaded) {
        // Draw the bass image larger - headstock (top) points in rotation direction
        const imgWidth = 140 * bassScale;
        const imgHeight = 210 * bassScale;
        ctx.shadowColor = '#f80'; ctx.shadowBlur = 25 * bassScale;
        ctx.drawImage(bassImage, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
        ctx.shadowBlur = 0;
      } else {
        // Fallback to sprite if image not loaded
        ctx.shadowColor = '#f80'; ctx.shadowBlur = 10 * bassScale;
        drawSprite(BASS_SPRITE, 0, 0, Math.round(5 * bassScale), '#fff', '#f80');
      }
      ctx.restore();
      
      // Enemies
      const uiScale = getUIScale();
      state.enemies.forEach(e => {
        ctx.save();
        ctx.translate(e.x, e.y);
        const baseSize = e.size * uiScale;
        const pulse = baseSize + Math.sin(e.pulsePhase) * 3 * uiScale;
        const px = Math.floor(pulse / 6);
        
        if (e.type === 'chord') {
          // Multi-colored glow for chord enemies
          const glowRadius = pulse * 1.6;
          const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
          glow.addColorStop(0, '#ffffcc');
          glow.addColorStop(0.3, e.color + 'aa');
          glow.addColorStop(0.6, 'rgba(255, 0, 255, 0.4)');
          glow.addColorStop(1, 'transparent');
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
          ctx.fill();

          // Pulsing outer ring
          ctx.strokeStyle = '#f0f';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.3 + Math.sin(e.pulsePhase * 2) * 0.2;
          ctx.beginPath();
          ctx.arc(0, 0, pulse * 1.3 + Math.sin(e.pulsePhase) * 5, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        } else {
          const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, pulse * 1.4);
          glow.addColorStop(0, e.color + 'cc');
          glow.addColorStop(0.5, e.color + '66');
          glow.addColorStop(1, 'transparent');
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(0, 0, pulse * 1.4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Music note symbol instead of sprite
        const noteSymbols = ['â™©', 'â™ª', 'â™«', 'â™¬'];
        const noteIndex = 'CDEFGAB'.indexOf(e.note[0]) % noteSymbols.length;
        const symbol = e.type === 'chord' ? 'â™«' : noteSymbols[noteIndex >= 0 ? noteIndex : 0];
        const fontSize = Math.round(pulse * 1.2);
        
        ctx.font = `bold ${fontSize}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Shadow
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = '#000';
        ctx.fillText(symbol, 3, 3);
        ctx.globalAlpha = 1;
        
        // Main symbol with glow
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 15;
        ctx.fillStyle = e.color;
        ctx.fillText(symbol, 0, 0);
        ctx.shadowBlur = 0;
        
        // Labels
        if (e.type === 'chord' && e.notes) {
          // Chord name at top
          const labelY = -pulse - 45 * uiScale;
          
          ctx.font = `bold ${Math.round(28 * uiScale)}px "Syne Mono"`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#f0f';
          ctx.shadowColor = '#f0f';
          ctx.shadowBlur = 15 * uiScale;
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3 * uiScale;
          ctx.strokeText(e.chordName, 0, labelY);
          ctx.fillText(e.chordName, 0, labelY);

          // Individual notes below chord name
          const noteY = labelY + 30 * uiScale;
          const noteSpacing = 40 * uiScale;
          const startX = -noteSpacing / 2;

          e.notes.forEach((n, i) => {
            const nx = startX + i * noteSpacing;
            const noteColor = NOTE_COLORS[n.name];
            const circleRadius = 16 * uiScale;

            // Background circle
            ctx.beginPath();
            ctx.arc(nx, noteY, circleRadius, 0, Math.PI * 2);
            ctx.fillStyle = n.hit ? noteColor : 'rgba(0,0,0,0.7)';
            ctx.fill();
            ctx.strokeStyle = n.hit ? '#fff' : noteColor;
            ctx.lineWidth = 2 * uiScale;
            ctx.stroke();

            // Note name
            ctx.font = `bold ${Math.round(18 * uiScale)}px "Syne Mono"`;
            ctx.fillStyle = n.hit ? '#000' : '#fff';
            ctx.shadowColor = n.hit ? '#fff' : noteColor;
            ctx.shadowBlur = (n.hit ? 15 : 8) * uiScale;
            ctx.fillText(n.name, nx, noteY + 1);
          });
          ctx.shadowBlur = 0;

        } else {
          // Single note label
          ctx.font = `bold ${Math.round(36 * uiScale)}px "Syne Mono"`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 18 * uiScale;
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 4 * uiScale;
          ctx.strokeText(e.note, 0, -pulse - 25 * uiScale);
          ctx.fillStyle = '#fff';
          ctx.fillText(e.note, 0, -pulse - 25 * uiScale);
        }
        ctx.restore();
      });
      
      // Particles
      state.particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill();
      });
      ctx.globalAlpha = 1;
      
      // Lightning
      state.lightning.forEach(l => {
        if (l.points.length < 2) return;
        ctx.save();
        ctx.globalAlpha = l.life;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.strokeStyle = '#ff8800';
        ctx.lineWidth = 20;
        ctx.shadowColor = '#ff8800';
        ctx.shadowBlur = 40;
        ctx.beginPath();
        ctx.moveTo(l.points[0].x, l.points[0].y);
        for (let i = 1; i < l.points.length; i++) ctx.lineTo(l.points[i].x, l.points[i].y);
        ctx.stroke();
        
        ctx.strokeStyle = '#ffcc44';
        ctx.lineWidth = 12;
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.moveTo(l.points[0].x, l.points[0].y);
        for (let i = 1; i < l.points.length; i++) ctx.lineTo(l.points[i].x, l.points[i].y);
        ctx.stroke();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 6;
        ctx.shadowColor = '#ffeeaa';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.moveTo(l.points[0].x, l.points[0].y);
        for (let i = 1; i < l.points.length; i++) ctx.lineTo(l.points[i].x, l.points[i].y);
        ctx.stroke();
        
        ctx.restore();
      });
      
      ctx.restore();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    resize();
    window.addEventListener('resize', resize);
    
    $('audio-visualizer').style.display = 'none';
    
    $('start-btn').addEventListener('click', start);
    $('restart-btn').addEventListener('click', () => location.reload());
    $('pause-btn').addEventListener('click', pause);
    $('resume-btn').addEventListener('click', resume);
    
    window.addEventListener('keydown', e => {
      if ((e.key === 'Escape' || e.code === 'Space') && state.running) {
        e.preventDefault();
        state.paused ? resume() : pause();
      }
    });
    
    render();
  </script>
</body>
</html>
